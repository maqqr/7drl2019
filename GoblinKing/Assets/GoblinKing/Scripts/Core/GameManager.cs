using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using LevelGen = LevelGenerator.Scripts.LevelGenerator;

namespace GoblinKing.Core
{
    public class GameManager : MonoBehaviour
    {
        public Keybindings keybindings;
        public GameObject playerObject;
        public GameObject visibilityDiamondObject;

        public GameObject[] levelGeneratorPrefabs;
        public GameObject perkTreePrefab;


        private int currentFloor = -1;
        private List<GameObject> dungeonFloors = new List<GameObject>();
        private Stack<GameStates.IGameView> gameViews = new Stack<GameStates.IGameView>();
        private Collider[] raycastResult = new Collider[1];

        public GameObject CurrentFloorObject
        {
            get
            {
                if (currentFloor >= 0 && currentFloor < dungeonFloors.Count)
                {
                    return dungeonFloors[currentFloor];
                }
                return null;
            }
        }

        public bool IsWalkable(Vector2Int position)
        {
            Vector3 worldPosition = Utils.ConvertToWorldCoord(position) + new Vector3(0f, 0.5f, 0f);
            int hits = Physics.OverlapSphereNonAlloc(worldPosition, 0.4f, raycastResult, ~0, QueryTriggerInteraction.Ignore);
            bool noObstacles = hits == 0;

            bool hasGroundUnderneath = Physics.Raycast(worldPosition, Vector3.down, 2.0f, ~0, QueryTriggerInteraction.Ignore);

            return hasGroundUnderneath && noObstacles;
        }

        public void NextDungeonFloor()
        {
            // Disable current level
            if (CurrentFloorObject != null)
            {
                CurrentFloorObject.SetActive(false);
            }

            // Go up one level
            currentFloor++;

            // Generate dungeon if it does not exist
            if (currentFloor >= dungeonFloors.Count)
            {
                if (levelGeneratorPrefabs.Length == 0) {
                    Debug.LogError("levelGeneratorPrefabs are missing!");
                    return;
                }

                // TODO: add some logic to generator prefab selection
                // generator should depend on which floor the player is going
                GameObject generatorPrefab = levelGeneratorPrefabs[0];
                GameObject generatorInstance = Instantiate(generatorPrefab);
                LevelGen generator = generatorInstance.GetComponent<LevelGen>();

                // Add empty game object that will be filled with objects generated by the level generator
                GameObject dungeonFloor = new GameObject("Floor" + currentFloor);
                dungeonFloor.AddComponent<DungeonLevel>();
                dungeonFloors.Add(dungeonFloor);
                generator.SectionContainer = CurrentFloorObject.transform;

                generator.GenerateLevel();

                dungeonFloor.GetComponent<DungeonLevel>().UpdateAllReferences();

                // Level generator has done its job and is no longer needed
                Destroy(generatorInstance);
            }
            else
            {
                CurrentFloorObject.SetActive(true);
            }
        }

        public void PreviousDungeonFloor()
        {
            if (currentFloor == 0)
            {
                Debug.LogWarning("Attempted to go below level 0");
                return;
            }

            // Disable current level
            CurrentFloorObject.SetActive(false);

            // Activate previous level
            currentFloor--;
            CurrentFloorObject.SetActive(true);
        }

        internal void AddView(GameStates.IGameView view)
        {
            gameViews.Push(view);
            view.Initialize(this);
        }

        private void Awake()
        {
            keybindings = new Keybindings();
            playerObject = FindObjectOfType<Player>().gameObject;
        }

        private void Start()
        {
            NextDungeonFloor();
            AddView(new GameStates.InGame());
        }

        // Update is called once per frame
        private void Update()
        {
            bool closeView = gameViews.Peek().UpdateView();

            if (closeView)
            {
                var view = gameViews.Pop();
                view.CloseView();

                // TODO: if last view was closed, quit the game
            }
        }
    }
}